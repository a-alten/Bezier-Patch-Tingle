//
//  MyGeometries.cpp
//
//   Sets up and renders 
//     - the ground plane, and
//     - the surface of rotation
//   for the Math 155A project #4.
//


// Use the static library (so glew32.dll is not needed):
#define GLEW_STATIC
#include "GL/glew.h" 
#include "GLFW/glfw3.h"

#include "LinearR3.h"		// Adjust path as needed.
#include "LinearR4.h"		// Adjust path as needed.
#include "MathMisc.h"       // Adjust path as needed

#include "ShaderBuild.h"

#include "MyGeometries.h"
#include "TextureProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"

// Material to underlie a texture map
phMaterial materialUnderTexture;

// Texture info
const int NumTextures = 4;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
	"tingleoutline.bmp",
	"tingleoutline2.bmp",
	"tinglenose.bmp",
    "black.bmp",
};


// VAO/VBO data
const int NumObjects = 5;
const int iFloor = 0;
const int iCircularSurf = 1;
const int iWall = 2;
const int iNose = 3;
const int iBeard = 4;

unsigned int myVBO[NumObjects];  // a Vertex Buffer Object holds an array of data
unsigned int myVAO[NumObjects];  // a Vertex Array Object - holds info about an array of vertex data;
unsigned int myEBO[NumObjects];  // a Element Array Buffer Object - holds an array of elements (vertex indices)

// Set up tecture maps
void SetupForTextures()
{
    // This material goes under the textures.
    // IY YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE TO DIFFERENT GEOMETRIES
    materialUnderTexture.SpecularColor.Set(1.0, 1.0, 1.0);
    materialUnderTexture.AmbientColor.Set(0.6, 0.6, 0.6);
    materialUnderTexture.DiffuseColor.Set(1.0, 1.0, 1.0);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 80.0;

    // Load texture maps
    RgbImage texMap;

    glUseProgram(phShaderPhongPhong);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);
    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
 #if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the phShaderPhongPhong uses the GL_TEXTURE_0 texture.
    glUseProgram(phShaderPhongPhong);
    glUniform1i(glGetUniformLocation(phShaderPhongPhong, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}


void MySetupSurfaces() {

    // Initialize the VAO's, VBO's and EBO's for objects

    glGenVertexArrays(NumObjects, &myVAO[0]);
    glGenBuffers(NumObjects, &myVBO[0]);
    glGenBuffers(NumObjects, &myEBO[0]);

	remeshTingle();

    check_for_opengl_errors();
}


void remeshTingle()
{

	// Blender to Opengl --> yzxw

	// Front face

	
	float frontTopCtrlPts[] = {
		0.0f, 10.30106f, 0.0f, 1.0f,		0.0f, 10.30106f, 0.0f, 1.0f,					0.0f, 10.30106f, 0.0f, 1.0f,					0.0f, 10.30106f, 0.0f, 1.0f,
		-0.479816f, 9.59689f, 0.0f, 1.0f,	-0.479816f, 9.59689f, 0.959632f, 1.0f / 3.0f,	0.479816f, 9.59689f, 0.959632f, 1.0f / 3.0f,	0.479816f, 9.59689f, 0.0f, 1.0f,
		-0.936664f, 8.68312f, 0.0f, 1.0f,	-0.936664f, 8.46089f, 1.2622f, 1.0f / 3.0f,		0.936664f, 8.46089f, 1.2622f, 1.0f / 3.0f,		0.936664f, 8.68312f, 0.0f, 1.0f,
		-1.65582f, 7.7762f, 0.0f, 1.0f,		-2.0567f, 6.95276f, 4.70353f, 1.0f / 3.0f,		2.0567f, 6.95276f, 4.70353f, 1.0f / 3.0f,		1.65582f, 7.7762f, 0.0f, 1.0f,
	};
	float frontBotCtrlPts[] = {
		-1.65582f, 7.7762f, 0.0f, 1.0f,		-2.0567f, 6.95276f, 4.70353f, 1.0f / 3.0f,		2.0567f, 6.95276f, 4.70353f, 1.0f / 3.0f,		1.65582f, 7.7762f, 0.0f, 1.0f,
		-3.77825f, 5.2568f, 0.0f, 1.0f,		-1.99543f, 3.78431f, 7.69815f, 1.0f / 3.0f,		1.99543f, 3.78431f, 7.69815f, 1.0f / 3.0f,		3.77825f, 5.2568f, 0.0f, 1.0f,
		-4.54576f, 0.165163f, 0.0f, 1.0f,	-2.3983f, 1.23684f, 6.17526f, 1.0f / 1.0f,		2.3983f, 1.23684f, 6.17526f, 1.0f / 1.0f,		4.54576f, 0.165163f, 0.0f, 1.0f,
		0.0f, 0.0f, 0.0f, 1.0f,				0.0f, 0.0f, 0.0f, 1.0f,							0.0f, 0.0f, 0.0f, 1.0f,							0.0f, 0.0f, 0.0f, 1.0f,

	};
	
	int numFloorVerts = meshRes * (2 * meshRes - 1);
	float* floorVerts = new float[8 * numFloorVerts];

	int cur = 0;
	float adjust = meshRes - 1.0f;

	for (int v = meshRes - 1; v >= 0; v--)
	{
		for (int u = 0; u < meshRes; u++)
		{
			float x = getQ(0, u / adjust, v / adjust, frontTopCtrlPts, 0);
			float y = getQ(1, u / adjust, v / adjust, frontTopCtrlPts, 0);
			float z = getQ(2, u / adjust, v / adjust, frontTopCtrlPts, 0);
			float w = getQ(3, u / adjust, v / adjust, frontTopCtrlPts, 0);

			floorVerts[cur + 0] = x / w;
			floorVerts[cur + 1] = y / w;
			floorVerts[cur + 2] = z / w;

			float dux = getQ(0, u / adjust, v / adjust, frontTopCtrlPts, 1);
			float duy = getQ(1, u / adjust, v / adjust, frontTopCtrlPts, 1);
			float duz = getQ(2, u / adjust, v / adjust, frontTopCtrlPts, 1);
			float duw = getQ(3, u / adjust, v / adjust, frontTopCtrlPts, 1);

			float dvx = getQ(0, u / adjust, v / adjust, frontTopCtrlPts, 2);
			float dvy = getQ(1, u / adjust, v / adjust, frontTopCtrlPts, 2);
			float dvz = getQ(2, u / adjust, v / adjust, frontTopCtrlPts, 2);
			float dvw = getQ(3, u / adjust, v / adjust, frontTopCtrlPts, 2);

			float rux = (dux*w - x*duw) / (w*w);
			float ruy = (duy*w - y*duw) / (w*w);
			float ruz = (duz*w - z*duw) / (w*w);

			float rvx = (dvx*w - x*dvw) / (w*w);
			float rvy = (dvy*w - y*dvw) / (w*w);
			float rvz = (dvz*w - z*dvw) / (w*w);

			float norm = sqrt((ruy*rvz - rvy*ruz)*(ruy*rvz - rvy*ruz) + (rux*rvz - rvx*ruz)*(rux*rvz - rvx*ruz) + (rux*rvy - rvx*ruy)*(rux*rvy - rvx*ruy));

			floorVerts[cur + 3] = (1)*(ruy*rvz - rvy*ruz) / norm;
			floorVerts[cur + 4] = (-1)*(rux*rvz - rvx*ruz) / norm;
			floorVerts[cur + 5] = (1)*(rux*rvy - rvx*ruy) / norm;

			if (v == meshRes - 1)
			{
				floorVerts[cur + 3] = 0.0f;
				floorVerts[cur + 4] = 1.0f;
				floorVerts[cur + 5] = 0.0f;
			}

			floorVerts[cur + 6] = u / adjust;
			floorVerts[cur + 7] = (v+adjust) / (adjust*2);

			cur += 8;
		}
	}
	
	for (int v = meshRes - 2; v >= 0; v--)
	{
		for (int u = 0; u < meshRes; u++)
		{
			float x = getQ(0, u / adjust, v / adjust, frontBotCtrlPts, 0);
			float y = getQ(1, u / adjust, v / adjust, frontBotCtrlPts, 0);
			float z = getQ(2, u / adjust, v / adjust, frontBotCtrlPts, 0);
			float w = getQ(3, u / adjust, v / adjust, frontBotCtrlPts, 0);

			floorVerts[cur + 0] = x / w;
			floorVerts[cur + 1] = y / w;
			floorVerts[cur + 2] = z / w;

			float dux = getQ(0, u / adjust, v / adjust, frontBotCtrlPts, 1);
			float duy = getQ(1, u / adjust, v / adjust, frontBotCtrlPts, 1);
			float duz = getQ(2, u / adjust, v / adjust, frontBotCtrlPts, 1);
			float duw = getQ(3, u / adjust, v / adjust, frontBotCtrlPts, 1);

			float dvx = getQ(0, u / adjust, v / adjust, frontBotCtrlPts, 2);
			float dvy = getQ(1, u / adjust, v / adjust, frontBotCtrlPts, 2);
			float dvz = getQ(2, u / adjust, v / adjust, frontBotCtrlPts, 2);
			float dvw = getQ(3, u / adjust, v / adjust, frontBotCtrlPts, 2);

			float rux = (dux*w - x*duw) / (w*w);
			float ruy = (duy*w - y*duw) / (w*w);
			float ruz = (duz*w - z*duw) / (w*w);

			float rvx = (dvx*w - x*dvw) / (w*w);
			float rvy = (dvy*w - y*dvw) / (w*w);
			float rvz = (dvz*w - z*dvw) / (w*w);

			float norm = sqrt((ruy*rvz - rvy*ruz)*(ruy*rvz - rvy*ruz) + (rux*rvz - rvx*ruz)*(rux*rvz - rvx*ruz) + (rux*rvy - rvx*ruy)*(rux*rvy - rvx*ruy));

			floorVerts[cur + 3] = (1)*(ruy*rvz - rvy*ruz) / norm;
			floorVerts[cur + 4] = (-1)*(rux*rvz - rvx*ruz) / norm;
			floorVerts[cur + 5] = (1)*(rux*rvy - rvx*ruy) / norm;

			if (v == 0)
			{
				floorVerts[cur + 3] = 0.0f;
				floorVerts[cur + 4] = -1.0f;
				floorVerts[cur + 5] = 0.0f;
			}

			floorVerts[cur + 6] = u / adjust;
			floorVerts[cur + 7] = v / (adjust * 2);

			cur += 8;
		}
	}
	

	cur = 0;

	int numFloorElts = (2 * meshRes)*(2 * (meshRes - 1));
	unsigned int* floorElts = new unsigned int[numFloorElts];

	for (int i = 0; i < 2 * (meshRes - 1); i++)
	{
		for (int j = 0; j < meshRes; j++)
		{
			floorElts[cur + 0] = i*meshRes + j;
			floorElts[cur + 1] = (i + 1)*meshRes + j;

			cur += 2;
		}
	}

	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
	glBindVertexArray(myVAO[iFloor]);
	glBufferData(GL_ARRAY_BUFFER, 8 * numFloorVerts * sizeof(float), floorVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, numFloorElts * sizeof(unsigned int), floorElts, GL_STATIC_DRAW);

	delete[] floorVerts;
	delete[] floorElts;


	// Back face


	float backTopCtrlPts[] = {
		0.0f, 10.30106f, 0.0f, 1.0f,		0.0f, 10.30106f, 0.0f, 1.0f,					0.0f, 10.30106f, 0.0f, 1.0f,					0.0f, 10.30106f, 0.0f, 1.0f,
		0.479816f, 9.59689f, 0.0f, 1.0f,	0.479816f, 9.59689f, -0.959634f, 1.0f / 3.0f,	-0.479816f, 9.59689f, -0.959634f, 1.0f / 3.0f,	-0.479816f, 9.59689f, 0.0f, 1.0f,
		0.936664f, 8.68312f, 0.0f, 1.0f,	1.78692f, 8.30571f, -3.11042f, 1.0f / 3.0f,		-1.78692f, 8.30571f, -3.11042f, 1.0f / 3.0f,	-0.936664f, 8.68312f, 0.0f, 1.0f,
		1.65582f, 7.7762f, 0.0f, 1.0f,		3.15889f, 5.90526f, -5.5925f, 1.0f / 3.0f,		-3.15889f, 5.90526f, -5.5925f, 1.0f / 3.0f,		-1.65582f, 7.7762f, 0.0f, 1.0f,
	};
	float backBotCtrlPts[] = {
		1.65582f, 7.7762f, 0.0f, 1.0f,		3.15889f, 5.90526f, -5.5925f, 1.0f / 3.0f,		-3.15889f, 5.90526f, -5.5925f, 1.0f / 3.0f,		-1.65582f, 7.7762f, 0.0f, 1.0f,
		3.77825f, 5.2568f, 0.0f, 1.0f,		7.20795f, 3.87419f, -8.34364f, 1.0f / 3.0f,		-7.20795f, 3.87419f, -8.34364f, 1.0f / 3.0f,	-3.77825f, 5.2568f, 0.0f, 1.0f,
		4.54576f, 0.165163f, 0.0f, 1.0f,	4.54576f, 0.165163f, -10.2678f, 1.0f / 3.0f,	-4.54576f, 0.165163f, -10.2678f, 1.0f / 3.0f,	-4.54576f, 0.165163f, 0.0f, 1.0f,
		0.0f, 0.0f, 0.0f, 1.0f,				0.0f, 0.0f, 0.0f, 1.0f,							0.0f, 0.0f, 0.0f, 1.0f,							0.0f, 0.0f, 0.0f, 1.0f,

	};

	int numBackVerts = meshRes * (2 * meshRes - 1);
	float* backVerts = new float[8 * numBackVerts];

	cur = 0;
	adjust = meshRes - 1.0f;

	for (int v = meshRes - 1; v >= 0; v--)
	{
		for (int u = 0; u < meshRes; u++)
		{
			float x = getQ(0, u / adjust, v / adjust, backTopCtrlPts, 0);
			float y = getQ(1, u / adjust, v / adjust, backTopCtrlPts, 0);
			float z = getQ(2, u / adjust, v / adjust, backTopCtrlPts, 0);
			float w = getQ(3, u / adjust, v / adjust, backTopCtrlPts, 0);

			backVerts[cur + 0] = x / w;
			backVerts[cur + 1] = y / w;
			backVerts[cur + 2] = z / w;

			float dux = getQ(0, u / adjust, v / adjust, backTopCtrlPts, 1);
			float duy = getQ(1, u / adjust, v / adjust, backTopCtrlPts, 1);
			float duz = getQ(2, u / adjust, v / adjust, backTopCtrlPts, 1);
			float duw = getQ(3, u / adjust, v / adjust, backTopCtrlPts, 1);

			float dvx = getQ(0, u / adjust, v / adjust, backTopCtrlPts, 2);
			float dvy = getQ(1, u / adjust, v / adjust, backTopCtrlPts, 2);
			float dvz = getQ(2, u / adjust, v / adjust, backTopCtrlPts, 2);
			float dvw = getQ(3, u / adjust, v / adjust, backTopCtrlPts, 2);

			float rux = (dux*w - x*duw) / (w*w);
			float ruy = (duy*w - y*duw) / (w*w);
			float ruz = (duz*w - z*duw) / (w*w);

			float rvx = (dvx*w - x*dvw) / (w*w);
			float rvy = (dvy*w - y*dvw) / (w*w);
			float rvz = (dvz*w - z*dvw) / (w*w);

			float norm = sqrt((ruy*rvz - rvy*ruz)*(ruy*rvz - rvy*ruz) + (rux*rvz - rvx*ruz)*(rux*rvz - rvx*ruz) + (rux*rvy - rvx*ruy)*(rux*rvy - rvx*ruy));

			backVerts[cur + 3] = (1)*(ruy*rvz - rvy*ruz) / norm;
			backVerts[cur + 4] = (-1)*(rux*rvz - rvx*ruz) / norm;
			backVerts[cur + 5] = (1)*(rux*rvy - rvx*ruy) / norm;

			if (v == meshRes - 1)
			{
				backVerts[cur + 3] = 0.0f;
				backVerts[cur + 4] = 1.0f;
				backVerts[cur + 5] = 0.0f;
			}

			backVerts[cur + 6] = 0.0f;
			backVerts[cur + 7] = 0.0f;

			cur += 8;
		}
	}

	for (int v = meshRes - 2; v >= 0; v--)
	{
		for (int u = 0; u < meshRes; u++)
		{
			float x = getQ(0, u / adjust, v / adjust, backBotCtrlPts, 0);
			float y = getQ(1, u / adjust, v / adjust, backBotCtrlPts, 0);
			float z = getQ(2, u / adjust, v / adjust, backBotCtrlPts, 0);
			float w = getQ(3, u / adjust, v / adjust, backBotCtrlPts, 0);

			backVerts[cur + 0] = x / w;
			backVerts[cur + 1] = y / w;
			backVerts[cur + 2] = z / w;

			float dux = getQ(0, u / adjust, v / adjust, backBotCtrlPts, 1);
			float duy = getQ(1, u / adjust, v / adjust, backBotCtrlPts, 1);
			float duz = getQ(2, u / adjust, v / adjust, backBotCtrlPts, 1);
			float duw = getQ(3, u / adjust, v / adjust, backBotCtrlPts, 1);

			float dvx = getQ(0, u / adjust, v / adjust, backBotCtrlPts, 2);
			float dvy = getQ(1, u / adjust, v / adjust, backBotCtrlPts, 2);
			float dvz = getQ(2, u / adjust, v / adjust, backBotCtrlPts, 2);
			float dvw = getQ(3, u / adjust, v / adjust, backBotCtrlPts, 2);

			float rux = (dux*w - x*duw) / (w*w);
			float ruy = (duy*w - y*duw) / (w*w);
			float ruz = (duz*w - z*duw) / (w*w);

			float rvx = (dvx*w - x*dvw) / (w*w);
			float rvy = (dvy*w - y*dvw) / (w*w);
			float rvz = (dvz*w - z*dvw) / (w*w);

			float norm = sqrt((ruy*rvz - rvy*ruz)*(ruy*rvz - rvy*ruz) + (rux*rvz - rvx*ruz)*(rux*rvz - rvx*ruz) + (rux*rvy - rvx*ruy)*(rux*rvy - rvx*ruy));

			backVerts[cur + 3] = (1)*(ruy*rvz - rvy*ruz) / norm;
			backVerts[cur + 4] = (-1)*(rux*rvz - rvx*ruz) / norm;
			backVerts[cur + 5] = (1)*(rux*rvy - rvx*ruy) / norm;

			if (v == 0)
			{
				backVerts[cur + 3] = 0.0f;
				backVerts[cur + 4] = -1.0f;
				backVerts[cur + 5] = 0.0f;
			}

			backVerts[cur + 6] = 0.0f;
			backVerts[cur + 7] = 0.0f;

			cur += 8;
		}
	}


	cur = 0;

	int numBackElts = (2 * meshRes)*(2 * (meshRes - 1));
	unsigned int* backElts = new unsigned int[numBackElts];

	for (int i = 0; i < 2 * (meshRes - 1); i++)
	{
		for (int j = 0; j < meshRes; j++)
		{
			backElts[cur + 0] = i*meshRes + j;
			backElts[cur + 1] = (i + 1)*meshRes + j;

			cur += 2;
		}
	}

	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall]);
	glBindVertexArray(myVAO[iWall]);
	glBufferData(GL_ARRAY_BUFFER, 8 * numBackVerts * sizeof(float), backVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, numBackElts * sizeof(unsigned int), backElts, GL_STATIC_DRAW);

	delete[] backVerts;
	delete[] backElts;

	// Ear

	float earCtrlPts[] = {
		0.0f, 6.60865f, 0.0f, 1.0f,			0.0f, 0.0f, 0.0f, 0.0f,						0.0f, 6.60865f, 0.0f, 1.0f,
		-3.07425f, 3.03058f, 0.0f, 1.0f,	0.0f, 0.0f, 3.07425f, 0.0f,					3.07425f, 3.03058f, 0.0f, 1.0f,
		0.0f, 0.0f, 0.0f, 1.0f,				0.0f, 0.0f, 0.0f, 0.0f,						0.0f, 0.0f, 0.0f, 1.0f,

	};


	int numEarVerts = meshRes * (2 * meshRes - 1);
	float* earVerts = new float[8 * numEarVerts];

	cur = 0;
	adjust = meshRes - 1.0f;

	for (int v = meshRes - 1; v >= 0; v--)
	{
		for (int u = 0; u < meshRes; u++)
		{
			float x = getQ2(0, u / adjust, v / adjust, earCtrlPts, 0);
			float y = getQ2(1, u / adjust, v / adjust, earCtrlPts, 0);
			float z = getQ2(2, u / adjust, v / adjust, earCtrlPts, 0);
			float w = getQ2(3, u / adjust, v / adjust, earCtrlPts, 0);

			earVerts[cur + 0] = x / w;
			earVerts[cur + 1] = y / w;
			earVerts[cur + 2] = z / w;

			if (v == meshRes - 1)
			{
				earVerts[cur + 0] = 0.0f;
				earVerts[cur + 1] = 6.60865f;
				earVerts[cur + 2] = 0.0f;
			}
			if (v == 0)
			{
				earVerts[cur + 0] = 0.0f;
				earVerts[cur + 1] = 0.0f;
				earVerts[cur + 2] = 0.0f;
			}

			float dux = getQ2(0, u / adjust, v / adjust, earCtrlPts, 1);
			float duy = getQ2(1, u / adjust, v / adjust, earCtrlPts, 1);
			float duz = getQ2(2, u / adjust, v / adjust, earCtrlPts, 1);
			float duw = getQ2(3, u / adjust, v / adjust, earCtrlPts, 1);

			float dvx = getQ2(0, u / adjust, v / adjust, earCtrlPts, 2);
			float dvy = getQ2(1, u / adjust, v / adjust, earCtrlPts, 2);
			float dvz = getQ2(2, u / adjust, v / adjust, earCtrlPts, 2);
			float dvw = getQ2(3, u / adjust, v / adjust, earCtrlPts, 2);

			float rux = (dux*w - x*duw) / (w*w);
			float ruy = (duy*w - y*duw) / (w*w);
			float ruz = (duz*w - z*duw) / (w*w);

			float rvx = (dvx*w - x*dvw) / (w*w);
			float rvy = (dvy*w - y*dvw) / (w*w);
			float rvz = (dvz*w - z*dvw) / (w*w);
			
			float norm = sqrt((ruy*rvz - rvy*ruz)*(ruy*rvz - rvy*ruz) + (rux*rvz - rvx*ruz)*(rux*rvz - rvx*ruz) + (rux*rvy - rvx*ruy)*(rux*rvy - rvx*ruy));

			earVerts[cur + 3] = (1)*(ruy*rvz - rvy*ruz) / norm;
			earVerts[cur + 4] = (-1)*(rux*rvz - rvx*ruz) / norm;
			earVerts[cur + 5] = (1)*(rux*rvy - rvx*ruy) / norm;

			if (v == meshRes - 1)
			{
				earVerts[cur + 3] = 0.0f;
				earVerts[cur + 4] = 1.0f;
				earVerts[cur + 5] = 0.0f;
			}

			if (v == 0)
			{
				earVerts[cur + 3] = 0.0f;
				earVerts[cur + 4] = -1.0f;
				earVerts[cur + 5] = 0.0f;
			}

			earVerts[cur + 6] = 0.0f;
			earVerts[cur + 7] = 0.0f;

			cur += 8;
		}
	}
	
	cur = 0;

	int numEarElts = (2 * meshRes)*(2 * (meshRes - 1));
	unsigned int* earElts = new unsigned int[numEarElts];

	for (int i = 0; i < 2 * (meshRes - 1); i++)
	{
		for (int j = 0; j < meshRes; j++)
		{
			earElts[cur + 0] = i*meshRes + j;
			earElts[cur + 1] = (i + 1)*meshRes + j;

			cur += 2;
		}
	}

	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCircularSurf]);
	glBindVertexArray(myVAO[iCircularSurf]);
	glBufferData(GL_ARRAY_BUFFER, 8 * numEarVerts * sizeof(float), earVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCircularSurf]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, numEarElts * sizeof(unsigned int), earElts, GL_STATIC_DRAW);

	delete[] earVerts;
	delete[] earElts;


	// Nose

	float noseCtrlPts[] = {
		0.0f, 7.60362f, 2.02034f, 1.0f,					0.0f, 7.60362f, 2.02034f, 1.0f,					0.0f, 7.60362f, 2.02034f, 1.0f,
		-3.91622f, 2.402518f, 1.3116f, 1.0f,			0.0f, 1.75232f*2.0f, 9.66408f*2.0f, 2.0f,		3.91622f, 2.402518f, 1.3116f, 1.0f,
		0.0f, 2.5672f*1.15f, 0.786663f*1.15f, 1.15f,	0.0f, 2.5672f*1.15f, 0.786663f*1.15f, 1.15f,	0.0f, 2.5672f*1.15f, 0.786663f*1.15f, 1.15f,

	};


	int numNoseVerts = meshRes * (2 * meshRes - 1);
	float* noseVerts = new float[8 * numNoseVerts];

	cur = 0;
	adjust = meshRes - 1.0f;

	for (int v = meshRes - 1; v >= 0; v--)
	{
		for (int u = 0; u < meshRes; u++)
		{
			float x = getQ2(0, u / adjust, v / adjust, noseCtrlPts, 0);
			float y = getQ2(1, u / adjust, v / adjust, noseCtrlPts, 0);
			float z = getQ2(2, u / adjust, v / adjust, noseCtrlPts, 0);
			float w = getQ2(3, u / adjust, v / adjust, noseCtrlPts, 0);

			noseVerts[cur + 0] = x / w;
			noseVerts[cur + 1] = y / w;
			noseVerts[cur + 2] = z / w;

			if (v == meshRes - 1)
			{
				noseVerts[cur + 0] = 0.0f;
				noseVerts[cur + 1] = 7.60362f;
				noseVerts[cur + 2] = 2.02034f;
			}
			if (v == 0)
			{
				noseVerts[cur + 0] = 0.0f;
				noseVerts[cur + 1] = 2.5672f;
				noseVerts[cur + 2] = 0.786663f;
			}

			float dux = getQ2(0, u / adjust, v / adjust, noseCtrlPts, 1);
			float duy = getQ2(1, u / adjust, v / adjust, noseCtrlPts, 1);
			float duz = getQ2(2, u / adjust, v / adjust, noseCtrlPts, 1);
			float duw = getQ2(3, u / adjust, v / adjust, noseCtrlPts, 1);

			float dvx = getQ2(0, u / adjust, v / adjust, noseCtrlPts, 2);
			float dvy = getQ2(1, u / adjust, v / adjust, noseCtrlPts, 2);
			float dvz = getQ2(2, u / adjust, v / adjust, noseCtrlPts, 2);
			float dvw = getQ2(3, u / adjust, v / adjust, noseCtrlPts, 2);

			float rux = (dux*w - x*duw) / (w*w);
			float ruy = (duy*w - y*duw) / (w*w);
			float ruz = (duz*w - z*duw) / (w*w);

			float rvx = (dvx*w - x*dvw) / (w*w);
			float rvy = (dvy*w - y*dvw) / (w*w);
			float rvz = (dvz*w - z*dvw) / (w*w);

			float norm = sqrt((ruy*rvz - rvy*ruz)*(ruy*rvz - rvy*ruz) + (rux*rvz - rvx*ruz)*(rux*rvz - rvx*ruz) + (rux*rvy - rvx*ruy)*(rux*rvy - rvx*ruy));

			noseVerts[cur + 3] = (1)*(ruy*rvz - rvy*ruz) / norm;
			noseVerts[cur + 4] = (-1)*(rux*rvz - rvx*ruz) / norm;
			noseVerts[cur + 5] = (1)*(rux*rvy - rvx*ruy) / norm;

			if (v == meshRes - 1)
			{
				noseVerts[cur + 3] = 0.0f;
				noseVerts[cur + 4] = 1.0f;
				noseVerts[cur + 5] = 0.0f;
			}

			if (v == 0)
			{
				noseVerts[cur + 3] = 0.0f;
				noseVerts[cur + 4] = -1.0f;
				noseVerts[cur + 5] = 0.0f;
			}

			noseVerts[cur + 6] = 0.0f;
			noseVerts[cur + 7] = 0.0f;

			noseVerts[cur + 6] = u / adjust;
			noseVerts[cur + 7] = v / adjust;

			cur += 8;
		}
	}

	cur = 0;

	int numNoseElts = (2 * meshRes)*(2 * (meshRes - 1));
	unsigned int* noseElts = new unsigned int[numNoseElts];

	for (int i = 0; i < 2 * (meshRes - 1); i++)
	{
		for (int j = 0; j < meshRes; j++)
		{
			noseElts[cur + 0] = i*meshRes + j;
			noseElts[cur + 1] = (i + 1)*meshRes + j;

			cur += 2;
		}
	}

	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iNose]);
	glBindVertexArray(myVAO[iNose]);
	glBufferData(GL_ARRAY_BUFFER, 8 * numNoseVerts * sizeof(float), noseVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iNose]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, numNoseElts * sizeof(unsigned int), noseElts, GL_STATIC_DRAW);

	delete[] noseVerts;
	delete[] noseElts;

	// Beard

	float beardCtrlPts[] = {
		0.005639f, 1.93923f, 1.38785f, 1.0f,			0.005639f, 1.93923f, 1.38785f, 1.0f,			0.005639f, 1.93923f, 1.38785f, 1.0f,
		-0.843905f, 0.932458f, 2.644f, 1.0f,			0.005639f, 2.28582f, 4.37433f, 1.0f,			1.04405f, 0.932459f, 2.644f, 1.0f,
		-0.304422f, -0.650965f, 3.7917f, 1.0f,			-0.304422f, -0.650965f, 3.7917f, 1.0f,			-0.304422f, -0.650965f, 3.7917f, 1.0f,

	};


	int numBeardVerts = meshRes * (2 * meshRes - 1);
	float* beardVerts = new float[8 * numBeardVerts];

	cur = 0;
	adjust = meshRes - 1.0f;

	for (int v = meshRes - 1; v >= 0; v--)
	{
		for (int u = 0; u < meshRes; u++)
		{
			float x = getQ2(0, u / adjust, v / adjust, beardCtrlPts, 0);
			float y = getQ2(1, u / adjust, v / adjust, beardCtrlPts, 0);
			float z = getQ2(2, u / adjust, v / adjust, beardCtrlPts, 0);
			float w = getQ2(3, u / adjust, v / adjust, beardCtrlPts, 0);

			beardVerts[cur + 0] = x / w;
			beardVerts[cur + 1] = y / w;
			beardVerts[cur + 2] = z / w;

			if (v == meshRes - 1)
			{
				beardVerts[cur + 0] = 0.005639f;
				beardVerts[cur + 1] = 1.93923f;
				beardVerts[cur + 2] = 1.38785f;
			}
			if (v == 0)
			{
				beardVerts[cur + 0] = -0.304422f;
				beardVerts[cur + 1] = -0.650965f;
				beardVerts[cur + 2] = 3.7917f;
			}

			float dux = getQ2(0, u / adjust, v / adjust, beardCtrlPts, 1);
			float duy = getQ2(1, u / adjust, v / adjust, beardCtrlPts, 1);
			float duz = getQ2(2, u / adjust, v / adjust, beardCtrlPts, 1);
			float duw = getQ2(3, u / adjust, v / adjust, beardCtrlPts, 1);

			float dvx = getQ2(0, u / adjust, v / adjust, beardCtrlPts, 2);
			float dvy = getQ2(1, u / adjust, v / adjust, beardCtrlPts, 2);
			float dvz = getQ2(2, u / adjust, v / adjust, beardCtrlPts, 2);
			float dvw = getQ2(3, u / adjust, v / adjust, beardCtrlPts, 2);

			float rux = (dux*w - x*duw) / (w*w);
			float ruy = (duy*w - y*duw) / (w*w);
			float ruz = (duz*w - z*duw) / (w*w);

			float rvx = (dvx*w - x*dvw) / (w*w);
			float rvy = (dvy*w - y*dvw) / (w*w);
			float rvz = (dvz*w - z*dvw) / (w*w);

			float norm = sqrt((ruy*rvz - rvy*ruz)*(ruy*rvz - rvy*ruz) + (rux*rvz - rvx*ruz)*(rux*rvz - rvx*ruz) + (rux*rvy - rvx*ruy)*(rux*rvy - rvx*ruy));

			beardVerts[cur + 3] = (1)*(ruy*rvz - rvy*ruz) / norm;
			beardVerts[cur + 4] = (-1)*(rux*rvz - rvx*ruz) / norm;
			beardVerts[cur + 5] = (1)*(rux*rvy - rvx*ruy) / norm;

			//if (v == meshRes - 1)
			//{
				//beardVerts[cur + 3] = 0.0f;
				//beardVerts[cur + 4] = 1.0f;
				//beardVerts[cur + 5] = 0.0f;
			//}

			//if (v == 0)
			//{
				//beardVerts[cur + 3] = 0.0f;
				//beardVerts[cur + 4] = -1.0f;
				//beardVerts[cur + 5] = 0.0f;
			//}

			beardVerts[cur + 6] = 0.0f;
			beardVerts[cur + 7] = 0.0f;

			cur += 8;
		}
	}

	cur = 0;

	int numBeardElts = (2 * meshRes)*(2 * (meshRes - 1));
	unsigned int* beardElts = new unsigned int[numBeardElts];

	for (int i = 0; i < 2 * (meshRes - 1); i++)
	{
		for (int j = 0; j < meshRes; j++)
		{
			beardElts[cur + 0] = i*meshRes + j;
			beardElts[cur + 1] = (i + 1)*meshRes + j;

			cur += 2;
		}
	}

	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iBeard]);
	glBindVertexArray(myVAO[iBeard]);
	glBufferData(GL_ARRAY_BUFFER, 8 * numBeardVerts * sizeof(float), beardVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iBeard]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, numBeardElts * sizeof(unsigned int), beardElts, GL_STATIC_DRAW);

	delete[] beardVerts;
	delete[] beardElts;
}



float getQ(int coord, float u, float v, float ctrlPts[], int d)
{
	// coord = 0 for x, 1 for y, 2 for z, 3 for w

	if (d == 1) // derivative with respect to u
	{
		if (coord < 3)
		{
			return	-3*(1 - u)*(1 - u) *		((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 12 + coord] * ctrlPts[4 * 12 + 3] +
												3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 8 + coord] * ctrlPts[4 * 8 + 3] +
												3 * v*v*(1 - v)*ctrlPts[4 * 4 + coord] * ctrlPts[4 * 4 + 3] +
												v*v*v*ctrlPts[4 * 0 + coord] * ctrlPts[4 * 0 + 3]) +
					(9*u*u - 12*u + 1) *		((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 13 + coord] * ctrlPts[4 * 13 + 3] +
												3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 9 + coord] * ctrlPts[4 * 9 + 3] +
												3 * v*v*(1 - v)*ctrlPts[4 * 5 + coord] * ctrlPts[4 * 5 + 3] +
												v*v*v*ctrlPts[4 * 1 + coord] * ctrlPts[4 * 1 + 3]) +
					(6*u - 9*u*u) *				((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 14 + coord] * ctrlPts[4 * 14 + 3] +
												3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 10 + coord] * ctrlPts[4 * 10 + 3] +
												3 * v*v*(1 - v)*ctrlPts[4 * 6 + coord] * ctrlPts[4 * 6 + 3] +
												v*v*v*ctrlPts[4 * 2 + coord] * ctrlPts[4 * 2 + 3]) +
					3*u*u *						((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 15 + coord] * ctrlPts[4 * 15 + 3] +
												3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 11 + coord] * ctrlPts[4 * 11 + 3] +
												3 * v*v*(1 - v)*ctrlPts[4 * 7 + coord] * ctrlPts[4 * 7 + 3] +
												v*v*v*ctrlPts[4 * 3 + coord] * ctrlPts[4 * 3 + 3]);
		}
		else
		{
			return	-3 * (1 - u)*(1 - u) *		((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 12 + coord] +
												3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 8 + coord] +
												3 * v*v*(1 - v)*ctrlPts[4 * 4 + coord] +
												v*v*v*ctrlPts[4 * 0 + coord]) +
					(9 * u*u - 12 * u + 1) *	((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 13 + coord] +
												3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 9 + coord] +
												3 * v*v*(1 - v)*ctrlPts[4 * 5 + coord] +
												v*v*v*ctrlPts[4 * 1 + coord]) +
					(6 * u - 9 * u*u) *			((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 14 + coord] +
												3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 10 + coord] +
												3 * v*v*(1 - v)*ctrlPts[4 * 6 + coord] +
												v*v*v*ctrlPts[4 * 2 + coord]) +
					3 * u*u *					((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 15 + coord] +
												3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 11 + coord] +
												3 * v*v*(1 - v)*ctrlPts[4 * 7 + coord] +
												v*v*v*ctrlPts[4 * 3 + coord]);
		}
	}
	if (d == 2) // derivative with respect to v
	{
		if (coord < 3)
		{
			return	-3 * (1 - v)*(1 - v) *		((1 - u)*(1 - u)*(1 - u)*ctrlPts[4 * 12 + coord] * ctrlPts[4 * 12 + 3] +
												3 * u*(1 - u)*(1 - u)*ctrlPts[4 * 13 + coord] * ctrlPts[4 * 13 + 3] +
												3 * u*u*(1 - u)*ctrlPts[4 * 14 + coord] * ctrlPts[4 * 14 + 3] +
												u*u*u*ctrlPts[4 * 15 + coord] * ctrlPts[4 * 15 + 3]) +
				(9 * v*v - 12 * v + 1) *		((1 - u)*(1 - u)*(1 - u)*ctrlPts[4 * 8 + coord] * ctrlPts[4 * 8 + 3] +
												3 * u*(1 - u)*(1 - u)*ctrlPts[4 * 9 + coord] * ctrlPts[4 * 9 + 3] +
												3 * u*u*(1 - u)*ctrlPts[4 * 10 + coord] * ctrlPts[4 * 10 + 3] +
												u*u*u*ctrlPts[4 * 11 + coord] * ctrlPts[4 * 11 + 3]) +
				(6 * v - 9 * v*v) *				((1 - u)*(1 - u)*(1 - u)*ctrlPts[4 * 4 + coord] * ctrlPts[4 * 4 + 3] +
												3 * u*(1 - u)*(1 - u)*ctrlPts[4 * 5 + coord] * ctrlPts[4 * 5 + 3] +
												3 * u*u*(1 - u)*ctrlPts[4 * 6 + coord] * ctrlPts[4 * 6 + 3] +
												u*u*u*ctrlPts[4 * 7 + coord] * ctrlPts[4 * 7 + 3]) +
				3 * v*v *						((1 - u)*(1 - u)*(1 - u)*ctrlPts[4 * 0 + coord] * ctrlPts[4 * 0 + 3] +
												3 * u*(1 - u)*(1 - u)*ctrlPts[4 * 1 + coord] * ctrlPts[4 * 1 + 3] +
												3 * u*u*(1 - u)*ctrlPts[4 * 2 + coord] * ctrlPts[4 * 2 + 3] +
												u*u*u*ctrlPts[4 * 3 + coord] * ctrlPts[4 * 3 + 3]);
		}
		else
		{
			return	-3 * (1 - v)*(1 - v) *		((1 - u)*(1 - u)*(1 - u)*ctrlPts[4 * 12 + coord] +
												3 * u*(1 - u)*(1 - u)*ctrlPts[4 * 13 + coord] +
												3 * u*u*(1 - u)*ctrlPts[4 * 14 + coord] +
												u*u*u*ctrlPts[4 * 15 + coord]) +
					(9 * v*v - 12 * v + 1) *	((1 - u)*(1 - u)*(1 - u)*ctrlPts[4 * 8 + coord] +
												3 * u*(1 - u)*(1 - u)*ctrlPts[4 * 9 + coord] +
												3 * u*u*(1 - u)*ctrlPts[4 * 10 + coord] +
												u*u*u*ctrlPts[4 * 11 + coord]) +
					(6 * v - 9 * v*v) *			((1 - u)*(1 - u)*(1 - u)*ctrlPts[4 * 4 + coord] +
												3 * u*(1 - u)*(1 - u)*ctrlPts[4 * 5 + coord] +
												3 * u*u*(1 - u)*ctrlPts[4 * 6 + coord] +
												u*u*u*ctrlPts[4 * 7 + coord]) +
					3 * v*v *					((1 - u)*(1 - u)*(1 - u)*ctrlPts[4 * 0 + coord] +
												3 * u*(1 - u)*(1 - u)*ctrlPts[4 * 1 + coord] +
												3 * u*u*(1 - u)*ctrlPts[4 * 2 + coord] +
												u*u*u*ctrlPts[4 * 3 + coord]);

		}
	}
	if (coord < 3)
	{
		return	(1 - u)*(1 - u)*(1 - u) * ((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 12 + coord] * ctrlPts[4 * 12 + 3] +
											3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 8 + coord] * ctrlPts[4 * 8 + 3] +
											3 * v*v*(1 - v)*ctrlPts[4 * 4 + coord] * ctrlPts[4 * 4 + 3] +
											v*v*v*ctrlPts[4 * 0 + coord] * ctrlPts[4 * 0 + 3]) +
			3 * u*(1 - u)*(1 - u)		* ((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 13 + coord] * ctrlPts[4 * 13 + 3] +
											3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 9 + coord] * ctrlPts[4 * 9 + 3] +
											3 * v*v*(1 - v)*ctrlPts[4 * 5 + coord] * ctrlPts[4 * 5 + 3] +
											v*v*v*ctrlPts[4 * 1 + coord] * ctrlPts[4 * 1 + 3]) +
			3 * u*u*(1 - u)				* ((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 14 + coord] * ctrlPts[4 * 14 + 3] +
											3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 10 + coord] * ctrlPts[4 * 10 + 3] +
											3 * v*v*(1 - v)*ctrlPts[4 * 6 + coord] * ctrlPts[4 * 6 + 3] +
											v*v*v*ctrlPts[4 * 2 + coord] * ctrlPts[4 * 2 + 3]) +
			u*u*u						* ((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 15 + coord] * ctrlPts[4 * 15 + 3] +
											3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 11 + coord] * ctrlPts[4 * 11 + 3] +
											3 * v*v*(1 - v)*ctrlPts[4 * 7 + coord] * ctrlPts[4 * 7 + 3] +
											v*v*v*ctrlPts[4 * 3 + coord] * ctrlPts[4 * 3 + 3]);
	}
	return	(1 - u)*(1 - u)*(1 - u) * ((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 12 + coord] + 3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 8 + coord] + 3 * v*v*(1 - v)*ctrlPts[4 * 4 + coord] + v*v*v*ctrlPts[4 * 0 + coord]) +
		3 * u*(1 - u)*(1 - u)       * ((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 13 + coord] + 3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 9 + coord] + 3 * v*v*(1 - v)*ctrlPts[4 * 5 + coord] + v*v*v*ctrlPts[4 * 1 + coord]) +
		3 * u*u*(1 - u)             * ((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 14 + coord] + 3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 10 + coord] + 3 * v*v*(1 - v)*ctrlPts[4 * 6 + coord] + v*v*v*ctrlPts[4 * 2 + coord]) +
		u*u*u				        * ((1 - v)*(1 - v)*(1 - v)*ctrlPts[4 * 15 + coord] + 3 * v*(1 - v)*(1 - v)*ctrlPts[4 * 11 + coord] + 3 * v*v*(1 - v)*ctrlPts[4 * 7 + coord] + v*v*v*ctrlPts[4 * 3 + coord]);
}



float getQ2(int coord, float u, float v, float ctrlPts[], int d)
{
	// coord = 0 for x, 1 for y, 2 for z, 3 for w

	if (d == 1) // derivative with respect to u
	{
		return	-2*(1 - u) *	((1 - v)*(1 - v)*ctrlPts[4 * 6 + coord] + 2 * v*(1 - v)*ctrlPts[4 * 3 + coord] + v*v*ctrlPts[4 * 0 + coord]) +
				(2 - 4*u) *		((1 - v)*(1 - v)*ctrlPts[4 * 7 + coord] + 2 * v*(1 - v)*ctrlPts[4 * 4 + coord] + v*v*ctrlPts[4 * 1 + coord]) +
				2*u	*			((1 - v)*(1 - v)*ctrlPts[4 * 8 + coord] + 2 * v*(1 - v)*ctrlPts[4 * 5 + coord] + v*v*ctrlPts[4 * 2 + coord]);
	}
	if (d == 2) // derivative with respect to v
	{
		return	-2 * (1 - v) *	((1 - u)*(1 - u)*ctrlPts[4 * 6 + coord] + 2 * u*(1 - u)*ctrlPts[4 * 7 + coord] + u*u*ctrlPts[4 * 8 + coord]) +
				(2 - 4*v) *		((1 - u)*(1 - u)*ctrlPts[4 * 3 + coord] + 2 * u*(1 - u)*ctrlPts[4 * 4 + coord] + u*u*ctrlPts[4 * 5 + coord]) +
				2*v *			((1 - u)*(1 - u)*ctrlPts[4 * 0 + coord] + 2 * u*(1 - u)*ctrlPts[4 * 1 + coord] + u*u*ctrlPts[4 * 2 + coord]);

	}
	return	(1 - u)*(1 - u) *	((1 - v)*(1 - v)*ctrlPts[4 * 6 + coord] + 2 * v*(1 - v)*ctrlPts[4 * 3 + coord] + v*v*ctrlPts[4 * 0 + coord]) +
			2 * u*(1 - u) *		((1 - v)*(1 - v)*ctrlPts[4 * 7 + coord] + 2 * v*(1 - v)*ctrlPts[4 * 4 + coord] + v*v*ctrlPts[4 * 1 + coord]) +
			u*u	*				((1 - v)*(1 - v)*ctrlPts[4 * 8 + coord] + 2 * v*(1 - v)*ctrlPts[4 * 5 + coord] + v*v*ctrlPts[4 * 2 + coord]);
}



void MyRemeshGeometries() 
{
	remeshTingle();

    check_for_opengl_errors();      // Watch the console window for error messages!
}



void MyRenderGeometries() {


    // Render front face

	LinearMapR4 matBase = viewMatrix;

	if (spinMode)
	{
		currentTime += animateIncrement;
	}
	matBase.Mult_glRotate(currentTime, 0.0f, 1.0f, 0.0f);

	LinearMapR4 matDemo = matBase;
    glBindVertexArray(myVAO[iFloor]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[0]);     // Choose marble texture

	if (eye)
	{
		glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose marble texture
	}

	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
													   // Draw the floor as a single triangle strip
	for (int i = 0; i < 2*(meshRes - 1); i++)
	{
		glDrawElements(GL_TRIANGLE_STRIP, (2 * meshRes), GL_UNSIGNED_INT, (void*)(i *(2 * meshRes) * sizeof(unsigned int)));
	}
	
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!w

	// Render back face

	glBindVertexArray(myVAO[iWall]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[0]);     // Choose Brick wall texture
	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
													   // Draw the wall as a single triangle strip
	for (int i = 0; i < 2 * (meshRes - 1); i++)
	{
		glDrawElements(GL_TRIANGLE_STRIP, (2 * meshRes), GL_UNSIGNED_INT, (void*)(i *(2 * meshRes) * sizeof(unsigned int)));
	}
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


	// Render ears

	matDemo = matBase;
	matDemo.Mult_glScale(0.9f, 0.9f, 0.9f);
	matDemo.Mult_glRotate(-PI / 16.0f, 1.0f, 0.0f, 0.0f);
	matDemo.Mult_glRotate(-PI/5.0f, 0.0f, 0.0f, 1.0f);
	matDemo.Mult_glTranslate(0.625157f, 2.038786f, 0.44715f);
	glBindVertexArray(myVAO[iCircularSurf]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[0]);     // Choose Brick wall texture
	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
													   // Draw the wall as a single triangle strip
	for (int i = 0; i < (meshRes - 1); i++)
	{
		glDrawElements(GL_TRIANGLE_STRIP, (2 * meshRes), GL_UNSIGNED_INT, (void*)(i *(2 * meshRes) * sizeof(unsigned int)));
	}
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

	//matDemo = viewMatrix;
	matDemo.Mult_glRotate(PI, 0.0f, 1.0f, 0.0f);
	glBindVertexArray(myVAO[iCircularSurf]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[0]);     // Choose Brick wall texture
	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
													   // Draw the wall as a single triangle strip
	for (int i = 0; i < (meshRes - 1); i++)
	{
		glDrawElements(GL_TRIANGLE_STRIP, (2 * meshRes), GL_UNSIGNED_INT, (void*)(i *(2 * meshRes) * sizeof(unsigned int)));
	}
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

	matDemo = matBase;
	matDemo.Mult_glScale(0.9f, 0.9f, 0.9f);
	matDemo.Mult_glRotate(-PI / 16.0f, 1.0f, 0.0f, 0.0f);
	matDemo.Mult_glRotate(PI / 5.0f, 0.0f, 0.0f, 1.0f);
	matDemo.Mult_glTranslate(-0.625157f, 2.038786f, 0.44715f);
	glBindVertexArray(myVAO[iCircularSurf]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[0]);     // Choose Brick wall texture
	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
													   // Draw the wall as a single triangle strip
	for (int i = 0; i < (meshRes - 1); i++)
	{
		glDrawElements(GL_TRIANGLE_STRIP, (2 * meshRes), GL_UNSIGNED_INT, (void*)(i *(2 * meshRes) * sizeof(unsigned int)));
	}
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

														//matDemo = viewMatrix;
	matDemo.Mult_glRotate(PI, 0.0f, 1.0f, 0.0f);
	glBindVertexArray(myVAO[iCircularSurf]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[0]);     // Choose Brick wall texture
	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
													   // Draw the wall as a single triangle strip
	for (int i = 0; i < (meshRes - 1); i++)
	{
		glDrawElements(GL_TRIANGLE_STRIP, (2 * meshRes), GL_UNSIGNED_INT, (void*)(i *(2 * meshRes) * sizeof(unsigned int)));
	}
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


	// Render nose

	matDemo = matBase;
	glBindVertexArray(myVAO[iNose]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[2]);     // Choose Brick wall texture
	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
													   // Draw the wall as a single triangle strip
	for (int i = 0; i < (meshRes - 1); i++)
	{
		glDrawElements(GL_TRIANGLE_STRIP, (2 * meshRes), GL_UNSIGNED_INT, (void*)(i *(2 * meshRes) * sizeof(unsigned int)));
	}
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


	// Render beard

	matDemo = matBase;
	glBindVertexArray(myVAO[iBeard]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose Brick wall texture
	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
													   // Draw the wall as a single triangle strip
	for (int i = 0; i < (meshRes - 1); i++)
	{
		glDrawElements(GL_TRIANGLE_STRIP, (2 * meshRes), GL_UNSIGNED_INT, (void*)(i *(2 * meshRes) * sizeof(unsigned int)));
	}
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

        
    check_for_opengl_errors();      // Watch the console window for error messages!
}

